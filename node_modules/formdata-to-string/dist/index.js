// src/index.ts
import { isErrored as streamIsErrored } from "stream";
import { inspect } from "util";
async function streamToString(data) {
  const chunks = [];
  for await (const chunk of data) {
    chunks.push(Buffer.from(chunk));
  }
  return Buffer.concat(chunks).toString("utf-8");
}
function isErrored(body) {
  return !!(body && (streamIsErrored ? streamIsErrored(body) : /state: 'errored'/.test(inspect(body))));
}
function isBuffer(buffer) {
  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
}
function extractBody(object, opts) {
  let source = null;
  let length = null;
  const boundary = (opts == null ? void 0 : opts.boundary) ? opts.boundary : `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`;
  const prefix = `--${boundary}\r
Content-Disposition: form-data`;
  const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
  const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
  const enc = new TextEncoder();
  const blobParts = [];
  const rn = new Uint8Array([13, 10]);
  length = 0;
  let hasUnknownSizeValue = false;
  for (const [name, value] of object) {
    if (typeof value === "string") {
      const chunk2 = enc.encode(
        `${prefix}; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`
      );
      blobParts.push(chunk2);
      length += chunk2.byteLength;
    } else {
      const chunk2 = enc.encode(
        `${prefix}; name="${escape(normalizeLinefeeds(name))}"${value.name ? `; filename="${escape(value.name)}"` : ""}\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`
      );
      blobParts.push(chunk2, value, rn);
      if (typeof value.size === "number") {
        length += chunk2.byteLength + value.size + rn.byteLength;
      } else {
        hasUnknownSizeValue = true;
      }
    }
  }
  const chunk = enc.encode(`--${boundary}--`);
  blobParts.push(chunk);
  length += chunk.byteLength;
  if (hasUnknownSizeValue) {
    length = null;
  }
  source = object;
  const action = async function* () {
    for (const part of blobParts) {
      if (part.stream) {
        yield* part.stream();
      } else {
        yield part;
      }
    }
  };
  const type = `multipart/form-data; boundary=${boundary}`;
  if (typeof source === "string" || isBuffer(source)) {
    length = Buffer.byteLength(source);
  }
  let iterator;
  const stream = new ReadableStream({
    async start() {
      iterator = action()[Symbol.asyncIterator]();
    },
    // @ts-expect-error Typings are off but this works.
    async pull(controller) {
      const { value, done } = await iterator.next();
      if (done) {
        queueMicrotask(() => {
          controller.close();
        });
      } else if (!isErrored(stream)) {
        controller.enqueue(new Uint8Array(value));
      }
      return controller.desiredSize > 0;
    },
    async cancel() {
      await iterator.return();
    },
    type: void 0
  });
  return {
    body: {
      stream,
      source,
      length
    },
    type
  };
}
async function formDataToString(form, opts = {}) {
  const {
    body: { stream }
  } = await extractBody(form, opts);
  return streamToString(stream);
}
export {
  formDataToString as default
};
/**
 * @license https://github.com/nodejs/undici/blob/e39a6324c4474c6614cac98b8668e3d036aa6b18/LICENSE
 * @see {@link https://github.com/nodejs/undici/blob/e39a6324c4474c6614cac98b8668e3d036aa6b18/lib/core/util.js#L333C1-L339C2}
 */
/**
 * @license https://github.com/nodejs/undici/blob/e39a6324c4474c6614cac98b8668e3d036aa6b18/LICENSE
 * @see {@link https://github.com/nodejs/undici/blob/e39a6324c4474c6614cac98b8668e3d036aa6b18/lib/core/util.js#L279-L282}
 */
/**
 * This is a paired down version of the `extractBody` function in `undici` that can convert a
 * `FormData` instance into a stream object that can be easily read out of.
 *
 * @license https://github.com/nodejs/undici/blob/e39a6324c4474c6614cac98b8668e3d036aa6b18/LICENSE
 * @see {@link https://github.com/nodejs/undici/blob/e39a6324c4474c6614cac98b8668e3d036aa6b18/lib/fetch/body.js#L31}
 */
/*! formdata-polyfill. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */
//# sourceMappingURL=index.js.map